<script>
    const { createApp, ref, reactive, computed, onMounted, watch, nextTick } = Vue;

    createApp({
        setup() {
            // --- ç‹€æ…‹ç®¡ç† ---
            const activeTab = ref('itinerary');
            const selectedDate = ref('è¡Œå‰');
            const isModalOpen = ref(false);
            const isEditing = ref(false);
            const editingId = ref(null);
            const mapInstance = ref(null);
            const weatherLoading = ref(false);
            const currentWeather = ref(null);
            const LOCAL_STORAGE_KEY = 'travel_planner_pro_db_v1';

            // è‡ªè£½ Modal ç‹€æ…‹
            const deleteModal = reactive({ isOpen: false, type: null, id: null });
            const systemMsg = reactive({ isOpen: false, text: '' });

            // --- æ•¸æ“šæ¨¡å‹ (é è¨­å€¼) ---
            const exchangeRateKRWtoHKD = ref(0.0058);
            const travelersCount = ref(6);
            const preTripList = ref([{ task: 'é è¨‚é¦–çˆ¾é…’åº—', done: true }, { task: 'è³¼è²·æ—…éŠä¿éšª', done: false }]);
            const shoppingList = ref([
                { id: 1, name: 'Olive Young é¢è†œ', done: false },
                { id: 2, name: 'Gentle Monster å¢¨é¡', done: false },
                { id: 3, name: 'æ¿Ÿå·å³¶æ©˜å­å·§å…‹åŠ›', done: false }
            ]);

            const cityCoordinates = {
                'é¦–çˆ¾': { lat: 37.5665, lng: 126.9780 },
                'æ¿Ÿå·': { lat: 33.4996, lng: 126.5312 },
                'é¦™æ¸¯': { lat: 22.3193, lng: 114.1694 }
            };

            const itinerary = ref([
                // Day 1: 24/12 é¦–çˆ¾
                { id: 1, date: '2025-12-24', time: '14:30', type: 'flight', city: 'é¦–çˆ¾', flightNumber: 'KE608', from: 'HKG', to: 'ICN', location: null, travelTime: 0, travelMode: 'subway' },
                { id: 2, date: '2025-12-24', time: '17:00', type: 'activity', city: 'é¦–çˆ¾', activity: 'æ©Ÿå ´å¿«ç·šå¾€å¼˜å¤§', location: 'AREX Station', icon: 'ğŸš†', lat: 37.5575, lng: 126.9245, travelTime: 60, travelMode: 'subway' },
                { id: 3, date: '2025-12-24', time: '19:00', type: 'activity', city: 'é¦–çˆ¾', activity: 'å¼˜å¤§çƒ¤è‚‰æ™šé¤', location: 'Hongdae', icon: 'ğŸ¥©', lat: 37.5563, lng: 126.9225, travelTime: 15, travelMode: 'walk' },
                // Day 2: 25/12 é¦–çˆ¾
                { id: 4, date: '2025-12-25', time: '10:00', type: 'activity', city: 'é¦–çˆ¾', activity: 'æ™¯ç¦å®®', location: 'Gyeongbokgung', icon: 'ğŸ¯', lat: 37.5796, lng: 126.9770, travelTime: 0, travelMode: 'subway' },
                { id: 5, date: '2025-12-25', time: '14:00', type: 'activity', city: 'é¦–çˆ¾', activity: 'åŒ—æ‘éŸ“å±‹æ‘', location: 'Bukchon', icon: 'ğŸ“·', lat: 37.5826, lng: 126.9850, travelTime: 20, travelMode: 'walk' },
                { id: 6, date: '2025-12-25', time: '18:00', type: 'activity', city: 'é¦–çˆ¾', activity: 'æ˜æ´è–èª•ç‡ˆé£¾', location: 'Myeong-dong', icon: 'ğŸ„', lat: 37.5636, lng: 126.9842, travelTime: 30, travelMode: 'subway' },
                // Day 3: 26/12 é¦–çˆ¾
                { id: 7, date: '2025-12-26', time: '11:00', type: 'activity', city: 'é¦–çˆ¾', activity: 'The Hyundai Seoul', location: 'Yeouido', icon: 'ğŸ›ï¸', lat: 37.5260, lng: 126.9284, travelTime: 0, travelMode: 'subway' },
                // Day 4: 27/12 é¦–çˆ¾ -> æ¿Ÿå·
                { id: 8, date: '2025-12-27', time: '11:00', type: 'flight', city: 'æ¿Ÿå·', flightNumber: '7C123', from: 'GMP', to: 'CJU', location: null, travelTime: 0, travelMode: 'car' },
                { id: 9, date: '2025-12-27', time: '15:00', type: 'activity', city: 'æ¿Ÿå·', activity: 'æ¶¯æœˆé‚‘å’–å•¡å»³', location: 'Aewol', icon: 'â˜•', lat: 33.4658, lng: 126.3195, travelTime: 40, travelMode: 'car' },
                // Day 5: 28/12 æ¿Ÿå·
                { id: 10, date: '2025-12-28', time: '10:00', type: 'activity', city: 'æ¿Ÿå·', activity: 'åŸå±±æ—¥å‡ºå³°', location: 'Seongsan', icon: 'â›°ï¸', lat: 33.4580, lng: 126.9425, travelTime: 0, travelMode: 'car' },
                // Day 6: 29/12 æ¿Ÿå·
                { id: 11, date: '2025-12-29', time: '10:00', type: 'activity', city: 'æ¿Ÿå·', activity: 'ç‰›å³¶ä¸€æ—¥éŠ', location: 'Udo', icon: 'ğŸš¢', lat: 33.5042, lng: 126.9538, travelTime: 0, travelMode: 'car' },
                // Day 7: 30/12 æ¿Ÿå·
                { id: 12, date: '2025-12-30', time: '12:00', type: 'activity', city: 'æ¿Ÿå·', activity: 'æ±é–€å¸‚å ´', location: 'Dongmun Market', icon: 'ğŸŠ', lat: 33.5126, lng: 126.5283, travelTime: 0, travelMode: 'car' },
                // Day 8: 31/12 æ¿Ÿå· -> å›ç¨‹
                { id: 13, date: '2025-12-31', time: '14:00', type: 'flight', city: 'æ¿Ÿå·', flightNumber: 'KE100', from: 'CJU', to: 'HKG', location: null, travelTime: 0, travelMode: 'car' },
            ]);

            const expenses = ref([
                { id: 1, description: 'å¼˜å¤§çƒ¤è‚‰ (å…¬æ•¸)', amount: 120000, currency: 'KRW', hkdAmount: 696, type: 'public' },
                { id: 2, description: 'ä¾¿åˆ©åº—é›¶é£Ÿ (ç§æ•¸)', amount: 5000, currency: 'KRW', hkdAmount: 29, type: 'private' },
            ]);
            
            // Modal ç”¨çš„æš«å­˜ç‰©ä»¶
            const modalItem = reactive({ date: '', time: '', type: 'activity', city: '', activity: '', location: '', flightNumber: '', from: '', to: '' });
            const newPreTripTask = ref('');
            const newShoppingItem = ref('');
            const newExpense = reactive({ description: '', amount: null, currency: 'KRW', type: 'public' });

            // --- è¨ˆç®—å±¬æ€§ ---
            const contentTitle = computed(() => (selectedDate.value === 'è¡Œå‰') ? 'è¡Œå‰æ¸…å–®' : `Day ${getDayNumber(selectedDate.value)} è¡Œç¨‹`);
            const travelDates = computed(() => Array.from(new Set(itinerary.value.map(item => item.date))).sort());
            const filteredItinerary = computed(() => itinerary.value.filter(item => item.date === selectedDate.value).sort((a, b) => a.time.localeCompare(b.time)));
            const currentCity = computed(() => filteredItinerary.value.length > 0 ? filteredItinerary.value[0].city : '');
            
            const accountingStats = computed(() => {
                let publicTotal = 0;
                let privateTotal = 0;
                expenses.value.forEach(e => {
                    if (e.type === 'public') publicTotal += e.hkdAmount;
                    else privateTotal += e.hkdAmount;
                });
                return {
                    total: publicTotal + privateTotal,
                    publicTotal: publicTotal,
                    privateTotal: privateTotal,
                    perPerson: publicTotal / travelersCount.value
                };
            });

            const itineraryWithTravel = computed(() => {
                const list = filteredItinerary.value;
                const result = [];
                for (let i = 0; i < list.length; i++) {
                    const currentItem = list[i];
                    result.push({ ...currentItem, uiKey: `item-${currentItem.id}` });
                    if (i < list.length - 1) {
                        const nextItem = list[i+1];
                        result.push({
                            isTravelInfo: true,
                            uiKey: `travel-${currentItem.id}-${nextItem.id}`,
                            targetId: nextItem.id, 
                            duration: nextItem.travelTime || 0,
                            mode: nextItem.travelMode || 'subway'
                        });
                    }
                }
                return result;
            });

            // --- æ–¹æ³• ---
            const selectDate = (date) => { selectedDate.value = date; };
            const getDay = (dateString) => new Date(dateString).getDate();
            const getMonth = (dateString) => (new Date(dateString).getMonth() + 1) + 'æœˆ';
            const getDayNumber = (dateString) => travelDates.value.indexOf(dateString) + 1;
            const getCityForDate = (dateString) => (itinerary.value.find(item => item.date === dateString) || {}).city || '';
            const getGoogleMapsUrl = (location) => `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(location)}`;
            const showSystemMsg = (text) => { systemMsg.text = text; systemMsg.isOpen = true; };

            // Modal æ“ä½œ
            const openAddModal = () => { 
                isEditing.value = false;
                editingId.value = null;
                Object.assign(modalItem, { time: '', type: 'activity', activity: '', location: '', flightNumber: '', from: '', to: '' });
                isModalOpen.value = true; 
            };

            const openEditModal = (item) => {
                isEditing.value = true;
                editingId.value = item.id;
                Object.assign(modalItem, { ...item });
                isModalOpen.value = true;
            };

            const closeModal = () => { isModalOpen.value = false; };
            
            const addPreTripItem = () => { if (newPreTripTask.value.trim()) { preTripList.value.push({ task: newPreTripTask.value.trim(), done: false }); newPreTripTask.value = ''; closeModal(); } };

            const handleSaveItem = () => {
                if (isEditing.value) {
                    const index = itinerary.value.findIndex(i => i.id === editingId.value);
                    if (index !== -1) {
                        const original = itinerary.value[index];
                        const locationChanged = modalItem.location !== original.location;
                        let newLat = original.lat;
                        let newLng = original.lng;
                        
                        if (locationChanged && modalItem.location) {
                            const city = getCityForDate(original.date);
                            const baseCoords = cityCoordinates[city] || cityCoordinates['é¦–çˆ¾'];
                            newLat = baseCoords.lat + (Math.random() - 0.5) * 0.05;
                            newLng = baseCoords.lng + (Math.random() - 0.5) * 0.05;
                        }

                        itinerary.value[index] = { ...original, ...modalItem, lat: newLat, lng: newLng };
                    }
                } else {
                    if (!selectedDate.value || selectedDate.value === 'è¡Œå‰') return;
                    const city = getCityForDate(selectedDate.value);
                    const baseCoords = cityCoordinates[city] || cityCoordinates['é¦–çˆ¾'];
                    const randomOffset = () => (Math.random() - 0.5) * 0.05;
                    
                    const itemToAdd = { 
                        ...modalItem, 
                        id: Date.now(), 
                        date: selectedDate.value, 
                        city: city,
                        icon: 'ğŸ“',
                        lat: modalItem.type === 'activity' ? baseCoords.lat + randomOffset() : null,
                        lng: modalItem.type === 'activity' ? baseCoords.lng + randomOffset() : null,
                        travelTime: 0,
                        travelMode: city === 'æ¿Ÿå·' ? 'car' : 'subway'
                    };
                    itinerary.value.push(itemToAdd);
                }
                closeModal();
            };

            const askDelete = (type, idOrIndex) => {
                deleteModal.type = type;
                deleteModal.id = idOrIndex;
                deleteModal.isOpen = true;
            };

            const confirmDelete = () => {
                const { type, id } = deleteModal;
                if (type === 'itinerary') {
                    itinerary.value = itinerary.value.filter(item => item.id != id);
                } else if (type === 'preTrip') {
                    preTripList.value.splice(id, 1);
                } else if (type === 'shopping') {
                    shoppingList.value.splice(id, 1);
                } else if (type === 'expense') {
                    expenses.value = expenses.value.filter(e => e.id !== id);
                }
                deleteModal.isOpen = false;
            };

            const updateTravelTime = (itemId, value) => { const item = itinerary.value.find(i => i.id === itemId); if (item) item.travelTime = parseInt(value) || 0; };
            const updateTravelMode = (itemId, value) => { const item = itinerary.value.find(i => i.id === itemId); if (item) item.travelMode = value; };

            const addShoppingItem = () => {
                if (newShoppingItem.value.trim()) {
                    shoppingList.value.push({ id: Date.now(), name: newShoppingItem.value.trim(), done: false });
                    newShoppingItem.value = '';
                }
            };
            
            const addExpense = () => {
                if (newExpense.amount > 0) {
                    const amount = parseFloat(newExpense.amount);
                    expenses.value.unshift({ 
                        ...newExpense, 
                        id: Date.now(), 
                        amount, 
                        hkdAmount: newExpense.currency === 'KRW' ? amount * exchangeRateKRWtoHKD.value : amount 
                    });
                    newExpense.description = ''; newExpense.amount = null;
                }
            };

            // --- åŒ¯å‡ºèˆ‡åŒ¯å…¥åŠŸèƒ½ ---
            const exportData = () => {
                const data = {
                    itinerary: itinerary.value,
                    expenses: expenses.value,
                    shoppingList: shoppingList.value,
                    preTripList: preTripList.value,
                    travelersCount: travelersCount.value,
                    exchangeRateKRWtoHKD: exchangeRateKRWtoHKD.value
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'travel_plan_backup.json';
                a.click();
                URL.revokeObjectURL(url);
            };

            const importData = (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.itinerary) itinerary.value = data.itinerary;
                        if (data.expenses) expenses.value = data.expenses;
                        if (data.shoppingList) shoppingList.value = data.shoppingList;
                        if (data.preTripList) preTripList.value = data.preTripList;
                        if (data.travelersCount) travelersCount.value = data.travelersCount;
                        if (data.exchangeRateKRWtoHKD) exchangeRateKRWtoHKD.value = data.exchangeRateKRWtoHKD;
                        showSystemMsg('åŒ¯å…¥æˆåŠŸï¼');
                    } catch (err) {
                        showSystemMsg('æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œç„¡æ³•åŒ¯å…¥ã€‚');
                        console.error(err);
                    }
                };
                reader.readAsText(file);
                event.target.value = ''; 
            };

            // --- æœ¬åœ°å­˜å„²é‚è¼¯ (Local Storage) - ä¿®æ­£ç‰ˆ ---
            const saveToLocalStorage = () => {
                try {
                    // æª¢æŸ¥æ˜¯å¦æ”¯æ´ LocalStorage
                    if (typeof localStorage === 'undefined') return;

                    const dataToSave = {
                        itinerary: itinerary.value,
                        expenses: expenses.value,
                        shoppingList: shoppingList.value,
                        preTripList: preTripList.value,
                        travelersCount: travelersCount.value,
                        exchangeRateKRWtoHKD: exchangeRateKRWtoHKD.value
                    };
                    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(dataToSave));
                } catch (e) {
                    console.warn("ç„¡æ³•å¯«å…¥ LocalStorage (å¯èƒ½æ˜¯éš±ç§æ¨¡å¼æˆ–ç©ºé–“ä¸è¶³):", e);
                }
            };

            const loadFromLocalStorage = () => {
                try {
                    // æª¢æŸ¥æ˜¯å¦æ”¯æ´ LocalStorage
                    if (typeof localStorage === 'undefined') return;

                    const saved = localStorage.getItem(LOCAL_STORAGE_KEY);
                    if (saved) {
                        const data = JSON.parse(saved);
                        if (data.itinerary) itinerary.value = data.itinerary;
                        if (data.expenses) expenses.value = data.expenses;
                        if (data.shoppingList) shoppingList.value = data.shoppingList;
                        if (data.preTripList) preTripList.value = data.preTripList;
                        if (data.travelersCount) travelersCount.value = data.travelersCount;
                        if (data.exchangeRateKRWtoHKD) exchangeRateKRWtoHKD.value = data.exchangeRateKRWtoHKD;
                    }
                } catch (e) {
                    console.warn("ç„¡æ³•è®€å– LocalStorage (å¯èƒ½æ˜¯éš±ç§æ¨¡å¼æˆ–è³‡æ–™ææ¯€):", e);
                    // ç™¼ç”ŸéŒ¯èª¤æ™‚ï¼Œä¿æŒä½¿ç”¨é è¨­è³‡æ–™ï¼Œä¸è®“ç¨‹å¼å´©æ½°
                }
            };

            const resetToDefault = () => {
                try {
                    if (typeof localStorage !== 'undefined') {
                        localStorage.removeItem(LOCAL_STORAGE_KEY);
                    }
                } catch (e) {
                    console.warn("æ¸…é™¤ LocalStorage å¤±æ•—");
                }
                location.reload();
            };

            // --- å¤©æ°£ & åœ°åœ– ---
            const wmoToEmoji = (code) => {
                if (code === 0) return 'â˜€ï¸'; if (code >= 1 && code <= 3) return 'â›…ï¸'; if (code >= 45 && code <= 48) return 'ğŸŒ«ï¸'; if (code >= 51 && code <= 67) return 'ğŸŒ§ï¸'; if (code >= 71 && code <= 77) return 'â„ï¸'; if (code >= 80 && code <= 82) return 'ğŸŒ¦ï¸'; if (code >= 95) return 'â›ˆï¸'; return 'â˜ï¸';
            };

            const fetchWeather = async () => {
                if (selectedDate.value === 'è¡Œå‰') return;
                const city = currentCity.value;
                if (!city || !cityCoordinates[city]) return;
                const { lat, lng } = cityCoordinates[city];
                const date = selectedDate.value;
                weatherLoading.value = true;
                currentWeather.value = null;
                
                const fallbackWeather = { max: city === 'æ¿Ÿå·' ? 12 : 2, min: city === 'æ¿Ÿå·' ? 6 : -5, icon: city === 'æ¿Ÿå·' ? 'â›…ï¸' : 'â„ï¸', desc: 'æ­·å²å¹³å‡ (é›¢ç·š)' };

                try {
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=auto&start_date=${date}&end_date=${date}`;
                    const res = await fetch(url);
                    if (!res.ok) throw new Error('Network response was not ok');
                    const data = await res.json();
                    
                    if (data.daily && data.daily.time.length > 0) {
                        currentWeather.value = { max: data.daily.temperature_2m_max[0], min: data.daily.temperature_2m_min[0], icon: wmoToEmoji(data.daily.weather_code[0]), desc: 'Open-Meteo é æ¸¬' };
                    } else {
                        currentWeather.value = fallbackWeather;
                    }
                } catch (e) { 
                    console.log("Weather fetch skipped/failed (using fallback):", e); 
                    currentWeather.value = fallbackWeather;
                } finally { 
                    weatherLoading.value = false; 
                }
            };

            const renderDailyMap = () => {
                const mapContainer = document.getElementById('daily-map');
                if (!mapContainer) return;
                
                // å¢åŠ æª¢æŸ¥ L æ˜¯å¦å­˜åœ¨ (é¿å… CDN è¼‰å…¥å¤±æ•—å°è‡´å´©æ½°)
                if (typeof L === 'undefined') {
                    mapContainer.innerHTML = '<div class="flex items-center justify-center h-full text-xs text-gray-400">åœ°åœ–ç„¡æ³•è¼‰å…¥ (é›¢ç·šæ¨¡å¼)</div>';
                    return;
                }

                if (mapInstance.value) { mapInstance.value.remove(); mapInstance.value = null; }
                const dayPoints = filteredItinerary.value.filter(item => item.lat && item.lng);
                
                try {
                    if (dayPoints.length === 0) {
                        const city = currentCity.value;
                        const center = cityCoordinates[city] || cityCoordinates['é¦–çˆ¾'];
                        mapInstance.value = L.map('daily-map').setView([center.lat, center.lng], 11);
                    } else {
                        mapInstance.value = L.map('daily-map');
                        const latLngs = [];
                        dayPoints.forEach((item) => {
                            L.marker([item.lat, item.lng]).addTo(mapInstance.value).bindPopup(`<b>${item.time}</b><br>${item.activity}`);
                            latLngs.push([item.lat, item.lng]);
                        });
                        if (latLngs.length > 1) { L.polyline(latLngs, { color: '#4A4A4A', weight: 3, dashArray: '5, 10' }).addTo(mapInstance.value); }
                        const bounds = L.latLngBounds(latLngs);
                        mapInstance.value.fitBounds(bounds, { padding: [30, 30] });
                    }
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '&copy; OpenStreetMap &copy; CARTO', subdomains: 'abcd', maxZoom: 19 }).addTo(mapInstance.value);
                } catch (e) {
                    console.error("Map render failed:", e);
                }
            };

            // --- å•Ÿå‹•èˆ‡ç›£è½ ---
            
            // 1. è¼‰å…¥æ™‚å…ˆè®€å– LocalStorage
            onMounted(() => {
                loadFromLocalStorage();
            });

            // 2. ç›£è½æ‰€æœ‰é‡è¦æ•¸æ“šï¼Œè®Šå‹•æ™‚è‡ªå‹•å„²å­˜
            watch(
                [itinerary, expenses, shoppingList, preTripList, travelersCount, exchangeRateKRWtoHKD], 
                () => { saveToLocalStorage(); }, 
                { deep: true }
            );

            watch(selectedDate, async (newVal) => { if (newVal !== 'è¡Œå‰' && activeTab.value === 'itinerary') { fetchWeather(); await nextTick(); renderDailyMap(); } }, { immediate: true });
            watch(activeTab, async (newVal) => { if (newVal === 'itinerary' && selectedDate.value !== 'è¡Œå‰') { await nextTick(); renderDailyMap(); } });
            watch(filteredItinerary, async () => { if (activeTab.value === 'itinerary' && selectedDate.value !== 'è¡Œå‰') { await nextTick(); renderDailyMap(); } }, { deep: true });

            return {
                activeTab, exchangeRateKRWtoHKD, selectedDate, travelDates, filteredItinerary, itineraryWithTravel, contentTitle, currentCity, selectDate, getDay, getMonth, getDayNumber, getCityForDate,
                preTripList, addPreTripItem,
                isModalOpen, openAddModal, openEditModal, closeModal, isEditing, modalItem, newPreTripTask, handleSaveItem,
                expenses, newExpense, accountingStats, addExpense, travelersCount,
                updateTravelTime, updateTravelMode,
                weatherLoading, currentWeather, getGoogleMapsUrl,
                shoppingList, newShoppingItem, addShoppingItem,
                exportData, importData,
                deleteModal, systemMsg, askDelete, confirmDelete, showSystemMsg,
                resetToDefault
            };
        }
    }).mount('#app');
</script>
